// Code generated by mockery v2.39.1. DO NOT EDIT.

package mocks

import (
	context "context"

	schema "github.com/goto/stencil/core/schema"
	mock "github.com/stretchr/testify/mock"

	stencilv1beta1 "github.com/goto/stencil/proto/gotocompany/stencil/v1beta1"
)

// SchemaService is an autogenerated mock type for the SchemaService type
type SchemaService struct {
	mock.Mock
}

// CheckCompatibility provides a mock function with given fields: ctx, nsName, schemaName, compatibility, data
func (_m *SchemaService) CheckCompatibility(ctx context.Context, nsName string, schemaName string, compatibility string, data []byte) error {
	ret := _m.Called(ctx, nsName, schemaName, compatibility, data)

	if len(ret) == 0 {
		panic("no return value specified for CheckCompatibility")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, []byte) error); ok {
		r0 = rf(ctx, nsName, schemaName, compatibility, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Create provides a mock function with given fields: ctx, nsName, schemaName, metadata, data
func (_m *SchemaService) Create(ctx context.Context, nsName string, schemaName string, metadata *schema.Metadata, data []byte) (schema.SchemaInfo, error) {
	ret := _m.Called(ctx, nsName, schemaName, metadata, data)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 schema.SchemaInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *schema.Metadata, []byte) (schema.SchemaInfo, error)); ok {
		return rf(ctx, nsName, schemaName, metadata, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *schema.Metadata, []byte) schema.SchemaInfo); ok {
		r0 = rf(ctx, nsName, schemaName, metadata, data)
	} else {
		r0 = ret.Get(0).(schema.SchemaInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *schema.Metadata, []byte) error); ok {
		r1 = rf(ctx, nsName, schemaName, metadata, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: ctx, namespace, schemaName
func (_m *SchemaService) Delete(ctx context.Context, namespace string, schemaName string) error {
	ret := _m.Called(ctx, namespace, schemaName)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, namespace, schemaName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteVersion provides a mock function with given fields: ctx, namespace, schemaName, version
func (_m *SchemaService) DeleteVersion(ctx context.Context, namespace string, schemaName string, version int32) error {
	ret := _m.Called(ctx, namespace, schemaName, version)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVersion")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int32) error); ok {
		r0 = rf(ctx, namespace, schemaName, version)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DetectSchemaChange provides a mock function with given fields: namespace, schemaName, fromVersion, toVersion, depth
func (_m *SchemaService) DetectSchemaChange(namespace string, schemaName string, fromVersion string, toVersion string, depth string) (*stencilv1beta1.SchemaChangedEvent, error) {
	ret := _m.Called(namespace, schemaName, fromVersion, toVersion, depth)

	if len(ret) == 0 {
		panic("no return value specified for DetectSchemaChange")
	}

	var r0 *stencilv1beta1.SchemaChangedEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, string) (*stencilv1beta1.SchemaChangedEvent, error)); ok {
		return rf(namespace, schemaName, fromVersion, toVersion, depth)
	}
	if rf, ok := ret.Get(0).(func(string, string, string, string, string) *stencilv1beta1.SchemaChangedEvent); ok {
		r0 = rf(namespace, schemaName, fromVersion, toVersion, depth)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*stencilv1beta1.SchemaChangedEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, string, string, string) error); ok {
		r1 = rf(namespace, schemaName, fromVersion, toVersion, depth)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: ctx, namespace, schemaName, version
func (_m *SchemaService) Get(ctx context.Context, namespace string, schemaName string, version int32) (*schema.Metadata, []byte, error) {
	ret := _m.Called(ctx, namespace, schemaName, version)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *schema.Metadata
	var r1 []byte
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int32) (*schema.Metadata, []byte, error)); ok {
		return rf(ctx, namespace, schemaName, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int32) *schema.Metadata); ok {
		r0 = rf(ctx, namespace, schemaName, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*schema.Metadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, int32) []byte); ok {
		r1 = rf(ctx, namespace, schemaName, version)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, int32) error); ok {
		r2 = rf(ctx, namespace, schemaName, version)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetLatest provides a mock function with given fields: ctx, namespace, schemaName
func (_m *SchemaService) GetLatest(ctx context.Context, namespace string, schemaName string) (*schema.Metadata, []byte, error) {
	ret := _m.Called(ctx, namespace, schemaName)

	if len(ret) == 0 {
		panic("no return value specified for GetLatest")
	}

	var r0 *schema.Metadata
	var r1 []byte
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*schema.Metadata, []byte, error)); ok {
		return rf(ctx, namespace, schemaName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *schema.Metadata); ok {
		r0 = rf(ctx, namespace, schemaName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*schema.Metadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) []byte); ok {
		r1 = rf(ctx, namespace, schemaName)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]byte)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string) error); ok {
		r2 = rf(ctx, namespace, schemaName)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetMetadata provides a mock function with given fields: ctx, namespace, schemaName
func (_m *SchemaService) GetMetadata(ctx context.Context, namespace string, schemaName string) (*schema.Metadata, error) {
	ret := _m.Called(ctx, namespace, schemaName)

	if len(ret) == 0 {
		panic("no return value specified for GetMetadata")
	}

	var r0 *schema.Metadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*schema.Metadata, error)); ok {
		return rf(ctx, namespace, schemaName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *schema.Metadata); ok {
		r0 = rf(ctx, namespace, schemaName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*schema.Metadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, schemaName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, namespaceID
func (_m *SchemaService) List(ctx context.Context, namespaceID string) ([]schema.Schema, error) {
	ret := _m.Called(ctx, namespaceID)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []schema.Schema
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]schema.Schema, error)); ok {
		return rf(ctx, namespaceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []schema.Schema); ok {
		r0 = rf(ctx, namespaceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]schema.Schema)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespaceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListVersions provides a mock function with given fields: ctx, namespaceID, schemaName
func (_m *SchemaService) ListVersions(ctx context.Context, namespaceID string, schemaName string) ([]int32, error) {
	ret := _m.Called(ctx, namespaceID, schemaName)

	if len(ret) == 0 {
		panic("no return value specified for ListVersions")
	}

	var r0 []int32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]int32, error)); ok {
		return rf(ctx, namespaceID, schemaName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []int32); ok {
		r0 = rf(ctx, namespaceID, schemaName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int32)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespaceID, schemaName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateMetadata provides a mock function with given fields: ctx, namespace, schemaName, meta
func (_m *SchemaService) UpdateMetadata(ctx context.Context, namespace string, schemaName string, meta *schema.Metadata) (*schema.Metadata, error) {
	ret := _m.Called(ctx, namespace, schemaName, meta)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMetadata")
	}

	var r0 *schema.Metadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *schema.Metadata) (*schema.Metadata, error)); ok {
		return rf(ctx, namespace, schemaName, meta)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *schema.Metadata) *schema.Metadata); ok {
		r0 = rf(ctx, namespace, schemaName, meta)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*schema.Metadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *schema.Metadata) error); ok {
		r1 = rf(ctx, namespace, schemaName, meta)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewSchemaService creates a new instance of SchemaService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSchemaService(t interface {
	mock.TestingT
	Cleanup(func())
}) *SchemaService {
	mock := &SchemaService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
